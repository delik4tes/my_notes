
### Записи

**Инвариант** - после действия, элементы находятся в тех же позициях, но в дргом порядке.

Инварианты цикла позволяют понять, корректно ли работает алгоритм. Инварианты циклов обладают следующими тремя свойствами:
1. **Инициализация.** Они справедливы перед первой итерацией цикла
2. **Сохранение.** Если они истинны перед очередной итерацией цикла, то остаются истинны и после неё.
3. **Завершение.** По завершении цикла инварианты позволяют убедиться в правлиьности алгоритма.

Порядок роста (order of growth) $\Theta$ - главный член формулы времени работы алгоритма, поскольку при больших значениях n членами меньшего порядка можно пренебречь.

### Упражнения

**2.1.1**
Исходный массив: A[31,41,26,41,58]
1. A[31,41,26,41,58]
2. A[26,31,41,41,58]
3. A[26,31,41,41,58]
4. A[26,31,41,41,58]

**2.1.2**
``` C++
template<class type> void insertSort(type *arr, int size){
    for (int j = 1; j < size; ++j){
        type key = arr[j];
        int i = j - 1;
        while (i >= 0 && arr[i] > key){
            arr[i+1] = arr[i];
            i = i - 1;
        }
        arr[i + 1] = key;
    }
}
```

**2.1.3**
```C++
template <class type> bool search (type *arr, int size, type v){
    for (int index = 0; index < size; ++index)
        if (v == arr[index])
            return true;
    return false;
}
```

**2.1.4**
~~~ C++
int* addition(int *A, int *B, int size){
    int *C = new int[size + 1];
    int buffer = 0;
    for (int i = size - 1; i >= 0 ; --i){
        int sum = A[i] + B[i] + buffer;
        if (sum > 1)
            buffer = 1;
        else
            buffer = 0;
        C[i+1] = sum % 2;
    }
    if(buffer == 1)
        C[0] = 1;
    return C;
}
~~~

**2.2.1**
$f(n) = \dfrac{n^3}{1000} - 100n^2 - 100n + 3$. Выражение данной функции: $\Theta(n^3)$

**2.2.2**



**2.2.3**
Всего у нас элементов $N$

**2.2.4**
Происходит проверка на определенное условие, после которого алгоритм выполняет определенный результат.