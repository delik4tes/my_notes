.model small
.stack 100h 
.data

port_address dw ? 		; базовый адрес порта 
text_out db '0123456789',0Dh,'$' 	; передаваемая строка
text_in db 50 dup(?) 		; буфер для считывания строки 
error_flag db ?			; признак ошибки приема

.code 
	; ========== инициализация сегментных регистров ======================
	mov ax,@data 
	mov ds,ax 
	
	xor ax,ax 	; т.к. адрес порта находится в яч. памяти 0000:0400h
	mov es,ax 		
	; чтение базового адресного порта COM1 
	mov dx,es:[400h] 
	mov port_address,dx 

	; разрешение доступа к регистрам DLL и DLM (установка DLAB=1) 
	; Регистры DLL и DLM используются для установки скорости передачи/приема. В них заносится делитель D
	; Управление битом DLAB производится в регистре LCR.
	
	; Назначение бит регистра LCR:
	; — Бит 7 – DLAB =1, доступ к регистрам DLL,DLM. 
	mov dx,port_address
	add dx,3 			; адрес регистра LCR 
	in al,dx 			; ввод содержимого регистра LCR в AL
	or al,10000000b 		; в старшем разряде AL - единица 
	out dx,al 

	; установка скорости передачи 
	mov dx,port_address		; смещение регистра DLL = 0 
	mov al,192 			; делитель   D = 115200/V (V=600 bps)
	out dx,al 			; младший байт делителя в DLL 
	add dx,1 			; адрес регистра DLM 
	mov al,0 			; старший байт делителя в DLM 
	out dx,al 

	; запрет доступа к регистрам DLL и DLM, установка битов данных и стоповых битов 
	mov dx,port_address 
	add dx,3 
	mov al,00011111b 		; изменение LCR
	out dx,al 			; 

	;запрет режима FIFO 
	mov dx,port_address 
	add dx,2 
	in al,dx 
	and al,0FEh ; устанавливаем нулевой бит в 0
	out dx,al

;========== передача ======================
	; настройка SI на передаваемую строку
	mov si,offset text_out 

output: 
	; опрос готовности передатчика 
	mov dx,port_address 
	add dx,5 ; dx -> LSR
	in al,dx 
	; Назначение бит регистра LSR
	; — Бит7 = 0, если запрещен режим FIFO.
	; — Бит6 – TEMPT =0, если регистр передатчика пуст.
	; — Бит5 – готовность записи данных в регистр передатчика.
	test al,00100000b		; проверяем пятый бит на готовность
	jz output 

	; Передача символа
	mov dx,port_address 
	mov al,[si] 
	out dx,al 

	inc si ; к следующему символу

	cmp al,'$' 
	jnz output ; продолжаем, пока не встретим '$'

;============= прием   ============= 

	; настройка SI на приемный буфер 
	mov si,offset text_in 
	
input: 
	mov dx,port_address 
	add dx,5 		; адрес регистра LSR 
	in al,dx 
	test al,1h 		; проверяем значение 0-го бита (готовность к передаче) 
	jz input 		; если в нём 0 - повторяем проверку (ждем), иначе идём дальше 

	and al,00000100b 	; оставляем только значение 2-го бита LSR
	mov error_flag,al	; error_flag=0 если ошибок нет

	; в любом случае считываем символ и запоминаем в буфере
	mov dx,port_address ; адрес регистра RBR 
	in al,dx 
	mov [si],al 

	cmp error_flag,0
	je no_error
 	mov al,'#'	; в случае ошибки будем выводить решетку вместо символа
no_error:
	mov dl,al 	; символ будет выводиться из dl

	; вывод символа, лежащего в DL
	mov ah,06h 
	int 21h 


	inc si ; к следующей позиции в буфере

	cmp byte ptr [si-1],0Dh 
	jnz input ; продолжить ввод, если не принят признак конца сообщения 0Dh 

;========== конец программы ==============

	mov ax,4C00h 
	int 21h 

end
