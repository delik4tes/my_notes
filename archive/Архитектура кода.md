Архитектура сервисов - что мы создаем
Архитектура кода - как мы создаем

### Принцип SOLID - всё об интерфейсах

#### Single responsibility - единсвенная ответственность
Пишем код таким образом, чтобы он решал одну задачу, будь это клас, интерфейс, метод. В итоге получаем меньше задач = используем меньше зависимостей = больше гибкость = проще тестировать = проще обслуживать = меньше кода.

1 класс/интерфейс = 1 проблема

#### Open/closed principe - открытость/закрытость
Расширять функционал, не трогать старый функционал, а добавлять новый. Условно сделать наследование и перегрузить функцию в другом классе. В итоге получаем: старая логика не пострадала, можно модифицровать обособленно, классы использующеие базовый интерфейс не заметят никакой разницы. Есть возможности где-то сохранить старую реализацию, а где-то использовать новую, или переключаться между ними.

#### Liscov substituuion - подстановка
Функции использующие ссылки на базовые классы должны иметь возможность использовать объекты производных классов не зная об этом. Если какой-то класс использует интерфейс или его реализацию, то его поведение не должно зависеть от конкретной реализации. 
>Совет: не реализовать то, что не собираешься использовать.

#### Interface segregation - разделение интерфейсов
Разбивать интерфейсы на решение одной проблемы, по возможности. Получаем меньше связанность компонентов, классы реализую только те интерфейсы, которые требуются.

#### Dependency Inversion - инверсия зависимостей
Не завязываться на конкретных реализациях, просто пользуемся интерфейсами. Связывать классы через интерфейсы. В итоге получаем для реализации четерых предыдущих принципов.


### Паттерны проектирования. Наборы SOLID'ных решений

Паттерны проектирования - этр инструмент. Не надо везде их впихивать. Сначала определяем проблему и определяем инструмент для её решения.

#### Паттерн Фасад
Сайт по продаже авто
~~~ mermaid
graph

A[Client] <--> B[CarService] 
A[Client] <--> C[CarSearcher]
~~~
Применям паттер:
~~~ mermaid
graph

A[Client] --> B[Facade] 
B --> C[CarService] 
B --> D[CarSearcher]
~~~
Плюсы: Упрощает взаимодействеи со сложной системой
Минусы: Фасад рискует стать объекто скрывающим слишком много деталей
Реализация: от одного интерфейса берется входной параметр, у другого выходной

#### Паттерн прокси
Задача: Собрать метрики и записать логи
Проблема: При реализации функциональность не относящийся к логике метода больше чем логической
Решение: Создаем класс с дополнительным функционалом, который содержить собирание метрики и логирование.
Выгода: Расширили функционал не изменяя логики программы. Прокси не меняет проксириуем объект, только расширяет функционал, в данном случае логирование. 

### Инкапсилируем логику в объекты

Плюсы: Изолиурем алгоритмы от ме тах их применения. Используем делегирование. Уходим от булирование кода.
Минусы: Усложняет программу засчёт дополниельных классов. Классы должен знать какую стратегию ему использовать.
