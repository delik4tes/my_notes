### Проблема
Push успешно завершится, только если для каждого отправляемого в origin коммита Git сможет найти предшественника. Пример:
![Пример](_attachments/6dfc348c03baad37564e0eb755d266fa.png)

Хронология этих коммитов следующая:  
- Сначала в origin были коммиты «1» и «2».
- Мы сделали pull (в локальном репозитории тоже оказались лишь эти два коммита).
- Потом мы закоммитили «3» и «4» в локальный репозиторий (но не пушили).
- Кто-то запушил коммит «5» в origin.

Теперь наша попытка запушить «3» и «4» в origin завершится ошибкой. Git откажется пристыковать наши коммиты к последнему коммиту «5» в origin, поскольку в local предшественником для коммита «3» является коммит «2» – а вовсе не «5», как в origin! Для Git важно, чтобы предшественник был тот же.  

### Решение проблемы
Проблема решается легко. Перед тем, как сделать push, мы сделаем pull (забираем коммит «5» себе). Тут вы можете спросить: «Секунду! А почему это забрать коммит «5» Git может, а послать коммиты «3» и «4» он не может? Вроде же ситуация симметричная в обе стороны». Правильный вопрос! А ответ на него простой. Если бы Git позволил отправить коммиты «3» и «4» в такой ситуации, то пришлось бы делать merge на стороне origin – а кто там будет разрешать конфликты? Некому. Поэтому Git заставляет вас сначала забрать свежие коммиты себе, сделать merge на своем компьютере (если будут конфликты, то разрешить их), а уже готовый результат он позволит вам отправить в origin командой push. При этом, никаких конфликтов в origin уже быть не может.  
  
Давайте посмотрим, как будет выглядеть локальная история, после того, как вы заберете коммит «5» командой pull.
![Итог](_attachments/4f4ed03b9437566f2e2fe7a8b84ce4f2.png)
> Вкратце. Нужно самому объединять на своём компьютере версии и потом уже отправлять на сервер готовый вариант.

